---
title: "Metacognitive Self-Renewal Process"
---

2024-09-18
I was trying to do A, and then I remembered B, and then I remembered B, and then I remembered C, and then I remembered C, and then I remembered I had to go out.
And as I was writing this, I remembered I didn't look up where to go this evening in the first place.

This is the wrong abstraction, and it's more like...
When I open kintone to do A, I notice unread, and when I read it and try to do action B in Discord, I notice unread again, so even if I notice the existence of unread while doing task A, I shouldn't interrupt task A to read it, but I should have the task of reading unread later. I wonder if I should add it to the end of the queue instead of the top of the stack.

I'm starting to be able to think about these things, the realization that the "[[observing self]]" that's looking at the "[[tasking self]]" is back.
When you're [[running two selves all the time]], the load is so high that it's like you're running a [[debug build]].
So, I had to make a release build and run it, but it's like turning off [[debug output]], so when a malfunction occurs, all I get is "[[something's wrong]]".

In this case, I think it was reasonable to kill the [[metacognitive self]] in June and July to get the performance, but the regeneration process of the metacognitive self after the end was undefined, so it took about 1.5 months before it naturally reappeared.
I'd love to be able to turn it on and off more smoothly.


- [[metacognition]]

---
This page is auto-translated from [/nishio/メタ認知自分の再生プロセス](https://scrapbox.io/nishio/メタ認知自分の再生プロセス) using DeepL. If you looks something interesting but the auto-translated English is not good enough to understand it, feel free to let me know at [@nishio_en](https://twitter.com/nishio_en). I'm very happy to spread my thought to non-Japanese readers.